#version 450

#define EPSILON 0.0001
#define M_PI 3.14159265359

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0, rgba8) uniform writeonly image2D img;

layout(binding = 1) buffer PrimeIndices {
    float[] size;
}; // this is used as both input and output for convenience

struct Sphere {
    vec3 centre;
    float radius;
};

struct Light {
    vec3 position;
    float intensity;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Triangle {
    vec3 v0;
    vec3 v1;
    vec3 v2;
};

float mollerTrumboreIntersectTriangle(vec3 orig, vec3 dir, vec3 v0, vec3 v1, vec3 v2){

    // adapted from Moller-Trumbore intersection algorithm pseudocode on wikipedia
    vec3 e1, e2; // Edge1, Edge2
    vec3 P, Q, T;
    float det, inv_det, u, v;
    float t;

    // vectors for edges sharing V1
    e1 = v1 - v0;
    e2 = v2 - v0;

    // begin calculating determinant - also used to calculate u param
    P = cross(dir, e2);

    // if determinant is near zero, ray lies in plane of triangle
    det = dot(e1, P);
    // NOT culling
    if (det > -EPSILON ){
        return -1.0;
    }
    inv_det = 1.0 / det;

    // calculate distance from v0 to ray origin
    T = orig - v0;

    // calculate u parameter and test bound
    u = dot(T, P) * inv_det;
    // the intersection lies outside of the triangle
    if (u < 0.0 || u > 1.0){
        return -1.0;
    }

    // prepare to test v parameter
    Q = cross(T, e1);

    // calculate v param and test bound
    v = dot(dir, Q) * inv_det;

    // the intersection is outside the triangle?
    if (v < 0.0 || (u + v) > 1.0){
        return -1.0;
    }

    t = dot(e2, Q) * inv_det;

    if (t > 0.0) {
        return t;
    }

    return -1.0;
}

void main() {

    vec3 cam_origin = vec3(0.0, 0.0, 0.0);


    mat4 view_mat = mat4(1.0);

    view_mat[3][0] = 0.0;
    view_mat[3][1] = 0.0;
    view_mat[3][2] = -1.0;

    cam_origin = (view_mat * vec4(cam_origin, 1.0)).xyz;

    vec2 raster_coord = gl_GlobalInvocationID.xy + vec2(0.5, 0.5);

    vec2 norm_coords = raster_coord / vec2(800.0, 800.0);

    vec2 screen_coord = vec2(-1.0, 1.0) + (vec2(2.0, -2.0) * norm_coords);

    vec3 screen_ray_intersection = vec3(screen_coord, 1.0);

    screen_ray_intersection = (view_mat * vec4(screen_ray_intersection, 1.0)).xyz;

    vec3 ray_direction = normalize((screen_ray_intersection - cam_origin));

    Ray ray = Ray(cam_origin, ray_direction);


    const int num = 4;

    const Triangle cube[num] = Triangle[num](
        Triangle(vec3(0.5, 0.5, 4.0), vec3(3.5, 0.5, 4.0), vec3(0.5, 3.5, 4.0)),
        Triangle(vec3(3.5, 3.5, 4.0), vec3(0.5, 3.5, 4.0), vec3(3.5, 0.5, 4.0)),
        Triangle(vec3(0.5, 0.5, 4.0), vec3(0.5, 3.5, 4.0), vec3(0.5, 3.5, 7.0)),
        Triangle(vec3(0.5, 0.5, 4.0), vec3(0.5, 3.5, 7.0), vec3(0.5, 0.5, 7.0))//,
//        Triangle(vec3(3.0, 3.0, 7.3), vec3(0.0, 3.0, 4.3), vec3(3.0, 3.0, 4.3))
    );

    //Triangle t = Triangle(vec3(0.0, 0.0, 4.0), vec3(0.0, 4.0, 4.5), vec3(2.5, 0.0, 4.0));

    Light l = Light(vec3(0.0, 7.0, 3.5), 0.5);

    vec4 to_write = vec4(0.0);

    for(int i=0; i<num; i++){

        Triangle t = cube[i];
        float a = mollerTrumboreIntersectTriangle(ray.origin, ray.direction, t.v0, t.v1, t.v2);

        if (a > EPSILON) {

            vec3 intersection_point = ray.origin + ray.direction * a;

            vec3 light_direction = normalize(l.position - intersection_point);

            float light_distance = distance(l.position, intersection_point);

            vec3 edge1 = t.v1 - t.v0;
            vec3 edge2 = t.v2 - t.v0;
            vec3 surface_normal = cross(edge2, edge1);

            float shade = dot(surface_normal, light_direction) * 20.0 * (1 / (light_distance * light_distance));

            to_write = vec4(shade, shade, shade, 1.0);
        }
    }

    imageStore(img, ivec2(gl_GlobalInvocationID.xy), to_write);

}



float ray_sphere_intersection(in Ray ray, in Sphere sphere){

    float a = dot(ray.direction, ray.direction);
    vec3 s0_r0 = ray.origin - sphere.centre;
    float b = 2.0 * dot(ray.direction, s0_r0);
    float c = dot(s0_r0, s0_r0) - (sphere.radius * sphere.radius);

    if (b*b - 4.0*a*c < 0.0) {
        return -1.0;
    }
    return (-b - sqrt((b*b) - 4.0*a*c))/(2.0*a);
}


void ray_triangle_intersection(in Ray ray, in Triangle triangle, out vec3 intersection_point, out bool intersects){

    vec3 edge1 = triangle.v1 - triangle.v0;
    vec3 edge2 = triangle.v2 - triangle.v0;
    vec3 h = cross(ray.direction, edge2);
    float a = dot(edge1, h);

    if (a > -EPSILON && a < EPSILON){
        // This ray is parallel to this triangle.
        intersection_point = vec3(0.0);
        intersects = false;
    }

    float f = 1.0 / a;

    // calculate distance from v0 to ray origin
    vec3 s = ray.origin - triangle.v0;

    // calculate u parameter and test bound
    float u = dot(s, h) * f;
    // the intersection lies outside of the triangle
    if (u < 0.0 || u > 1.0) {
        intersection_point = vec3(0.0);
        intersects = false;
    }

    vec3 q = cross(s, edge1);
    float v = f * dot(ray.direction, q);
    if (v < 0.0 || (u + v) > 1.0){
        intersection_point = vec3(0.0);
        intersects = false;
    }

    // At this stage we can compute t to find out where the intersection point is on the line.
    float t = f * dot(edge2, q);
    if (t > EPSILON) // ray intersection
    {
        intersection_point = ray.origin + ray.direction * t;
        intersects = true;
    }
    else {
        intersection_point = vec3(0.0);
        intersects = false;
    }

}